# 第2章 信息的表示与存储

## 2.1 信息存储

* 字节(byte): 内存最小可寻址单位.

* 虚拟内存(virtual memory): 计算机程序将内存视为一个非常大的字节数组.

* 地址(address): 内存的字节数组中每一个元素(即: 每个字节)都有一个数字标识. 这个标识就是内存的地址. 

* 虚拟地址空间(virtual address space): 内存地址的集合. 

  虚拟地址空间是站在程序的视角的一个概念性映象. 实际的实现是将DRAM(即我们常说的内存条), 闪存, 磁盘存储器, 特殊硬件和操作系统结合起来, 为程序提供一个看上去是统一的字节数组.  

* 字长(word size): 每台计算机的都有一个字长, 用来指明指针数据的标称大小(nominal size). (即我们常说的多少位的计算机)

  虚拟内存的地址的标识是以一个字长来编码. 即字长决定了虚拟地址空间的大小.

  一个字长为w位的计算机, 它的虚拟地址范围为 $[0, 2^w - 1]$.

  * 32位机器, 虚拟内存大小为 $2^{32}$ = 4 GB
  * 64位机器, 虚拟内存大小为 $2^{64}$ = 16 EB, 因为太大了, 所以目前大多数系统只用了48位, 即 $2^{48}$ = 256 TB.


* 寻址规则: 一个多字节对象会被存储为多个**连续**的字节序列, 而这个对象的地址为使用字节中最小的地址.

* 字节排列顺序: 

  大端序(big endian): 最高有效字节在前面的方式.

  小端序(little endian): 最低有效字节在前面的方式.

* 位向量: 固定长度为 w, 由 0 或 1 组成的串. 如 `[0 , 1 , 0, 1]`.

  位向量的应用: 集合之间的计算. 

  掩码: 设置为有效信号的集合.

  > 任何bit异或0, 等于它自身. 
  > 任何bit异或1, 等于它自身取反.
  > x ^ y = (x & -y) | (-x & y)

## 2.2 整数的表示

* 无符号数编码的定义

对于向量 $\vec{x}=[x_{w-1}, x_{w-2}, ..., x_1, x_0]:$

$$
B2U(\vec{x}) \doteq \sum_{i=0}^{w-1} x_i \cdot 2^i 

\tag{2.1}
$$

* 补码数编码的定义

对于向量 $\vec{x}=[x_{w-1}, x_{w-2}, ..., x_1, x_0]:$

$$ 
B2T(\vec{x}) \doteq -x_{w-1}*2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i

\tag{2.3} 
$$

* 补码转无符号

对于 $TMin_w <= x <= TMax_w$

$$
T2U(x) = 
\begin{cases}
  x, & x >= 0
  \\
  x + 2^w, & x < 0
\end{cases}

\tag{2.5}
$$

$$
T2U(x) = B2U(T2B(x)) = x + x_{w-1} \cdot 2^w

\tag{2.6}
$$


* 无符号转补码

对于 $0 <= x <= UMax_w$

$$

U2T(x) = 
\begin{cases}
  x, & x <= TMax_w
  \\
  x - 2^w,& x > TMax_w
\end{cases}

\tag{2.7}
$$

$$

U2T(x) = B2T(U2B(x)) = x - x_{w-1} \cdot 2^w

\tag{2.8}
$$

* 截断无符号数 

令 $\vec{x}$ 等于向量 $[x_{w-1}, x_{w-2}, ..., x_1, x_0]$, 而 $\vec{x}`$ 是将其截断为 $k$ 位后的结果: $\vec{x}` = [x_{k-1}, x_{k-2}, ..., k_1, k_0]$. 令 $x=B2U(\vec{x})$, $x`=B2U(\vec{x}`)$, 则 $x` = x \bmod 2^k$

即:

$$
B2U_k(x_k) = B2U_w(x_w) \bmod 2^k
$$

* 截断补码数

$$
x` = B2T(x \bmod 2^k)
$$

## 2.3 整数运算

* 无符号加法

对满足 $0 <= x , y < 2^w$ 的 $x$, $y$ 有:

$$
x + y = 
\begin{cases}
  x+y, & x + y < 2^w & 正常
  \\
  x+y-2^w, & 2^w <= x+y < 2^{w+1} & 溢出
\end{cases}
$$

* 检测无符号加法溢出

对在范围 $[0, UMax]$中的 $x$ 和 $y$, 令 $s \doteq x + {^u_w}y$, 则对计算$s$, 当且仅当 $s < x$ 时,发生溢出.

> 或者等价与 $s < y$ 时, 发生溢出

* 无符号数求反

$$
-{^u_w}x = 
\begin{cases}
  x, & x = 0
  \\
  2^w - x, & x > 0
\end{cases}
$$

* 补码加法

对于满足 $-2^{w-1} <= x, y <= 2^{w-1} - 1$ 的 $x$, $y$. 有:

$$
x + {^T_w}y = 
\begin{cases}
  x + y - 2^w, & x + y > 2^{w-1} -1 & 正溢出
  \\
  x + y, & -2^{w-1} <= x + y <= 2^{w-1} - 1 & 正常
  \\
  x + y + 2^w, & x + y < -2^{w-1} & 负溢出
\end{cases}

$$

* 检测补码加法溢出

对满足 $TMin_w <= x, y <= TMax_w$ 的 $x$ 和 $y$, 令 $s \doteq x + {^t_w}y$.

$$
\begin{cases}
  x > 0 \And y > 0 \And s < 0 & 情况 1 & 正溢出
  \\
  x < 0 \And y < 0 \And s > 0 & 情况 2 & 负溢出
\end{cases}
$$

* 补码的非(补码去反)

对满足 $TMin_w <= x <= TMax_w$ 的 $x$, 其补码的非($-{^t_w}x$)由下公式给出

$$
-{^t_w}x =
\begin{cases}
  -x, & x > TMin_w
  \\
  TMin_w, & x = TMin_w
\end{cases}
$$

* 如何快速计算补码的非

  - 方法1: 取反加一
  - 方法2: 寻找最右的bit位等于1的位置$k$, 将$k$位左侧全部取反.

* 无符号乘法

对满足 $0 <= x, y <= UMax_w$的$x$, $y$有:

$$
x * {^u_w}y = (x \cdot y) \bmod 2^w

\tag{2.16}
$$


* 补码乘法

对满足 $TMin_w <= x, y <= TMax_w$ 的x, y有:

$$
x * {^t_w}y = U2T( x \cdot y \bmod 2^w )
$$


* $x$ 乘以 $2^k$, 等于 $x << k$

* $x$ 乘以常数 $K$, 编译器会将 $K$ 的二进制表达为一组0与1交替的序列:

$$
 [(0...0)(1...1)(0...0)...(1...1)]
$$

设从n到m位(n>m)是一段连续的1, 则:
  
形式A: $(x << n) + (x << (n-1)) + ... + (x << m)$

形式B: $(x << (n + 1)) - (x << m)$


> 整数除法总是舍入到零.

* 除以2的幂的无符号除法
对 满足 $ 0 <= k < w$
$$
{^u_w}x / 2^{k} = x >> k
$$

* 除以2的幂的补码除法

当 x >= 0 时, 与无符号数相同
当 x < 0 时, 需要加偏置(biasing)进行修正($bias = 2^k - 1$)

对 满足 $ 0 <= k < w$

$$

\begin{cases}
  {^t_w}x / 2^{k} = x >> k, & x >= 0
  \\
  (({^t_w}x + (2^k - 1)) / 2^{k}), & x < 0 
\end{cases}

$$

## 2.4 浮点数

### 2.4.2 IEEE浮点表示法

$$
V = (-1)^s \cdot M \cdot 2^E
$$

看公式可知, 一个浮点数的位向量分成了3个部分:

* 符号(sign): s 决定V是正数还是负数
* 有效数(Significand)
* 阶码(Exponent)

其中:

* 单精度(32位)浮点数: s = 1 bit, exp = 8 bit, frac = 23 bit, $bias = 2^{8-1} - 1= 2^7 - 1 = 127$
* 双精度(64位)浮点数: s = 1 bit, exp = 11 bit, frac = 52 bit, $bias = 2^(11 - 1) - 1 = 2^{10} -1 = 1023$





根据 exp 的值不同, 又分了3种值:

* 规格化的值 (Normalized number): exp != [0, ..., 0] && exp != [1, ..., 1]时.

$$

M = 1 + f

\\

E = e - bias

$$


* 非规格化的值 (Denormalized number): exp == [0, ..., 0]

$$
M = f
\\
E = 1 - bias
$$

* 特殊值(Spacial number): exp == [1, ..., 1]

