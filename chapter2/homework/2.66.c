#include <printf.h>
// 生成表示 x 中最左边 1 的掩码。
// 举例: 0xff00 -> 0x8000, 0x6600 -> 0x4000
// if x == 0, return 0
//
// 分析: 题目要求找到x最左边1的所在位置. 用位向量表示
// 返回结果应该为: 0b00001000000
// 根据: 0b0001000 - 0b0000001 = 0b0000111
// 所以第一步: 需要将x先转为0b0000111格式, 即: 左边最高位1的后全部为1
//           这一步最容易想到的是for循环, 但不能用, 这里使用二分发.每次将一半的位与另一半取或, 合并为1
// 第二步: 如何在转为要求返回的掩码格式呢? 根据上面的计算公式:  0b0001000 - 0b0000001 = 0b0000111
// 即将第一步的结果在右移一位, 在+1, 即可得到返回的掩码值
int leftmost_one(unsigned x) {
  x |= x >> 16;
  x |= x >> 8;
  x |= x >> 4;
  x |= x >> 2;
  x |= x >> 1;
  return (x >> 1) + 1 * (x != 0);
}

int main() {
  int x = 0xff00;
  printf("%x\n", leftmost_one(x));

  x = 0x6600;
  printf("%x\n", leftmost_one(x));

  x = 0x0;
  printf("%x\n", leftmost_one(x));

  x = 0b0110;
  printf("%x\n", leftmost_one(x));
}